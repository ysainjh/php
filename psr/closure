PHP中闭包Closure::bind详解
php中 闭包我们也可以叫做匿名函数。
$say = function(){
    return '我是匿名函数';
};
echo $say(); //这是最直接调用匿名函数方式 输出 我是匿名函数
function test(Closure $callback){
    return $callback();
}
echo test($say); //这是间接调用匿名函数方式 同样输出 我是匿名函数

当然也可以这样写 :
echo test(function(){
    return '我是匿名函数';
});

php的public、protected、private三种访问控制模式的区别
public: 公有类型，
        在子类可以通过self::var调用public静态方法或属性,
        在子类调用父类方法parent::method
        在实例中可以能过$obj->var来调用public类型的方法或属性
protected: 受保护类型，
        在子类中可以通过self::var调用protected方法或属性,
        在子类调用父类方法parent::method
        在实例中不能通过$obj->var来调用protected类型的方法或属性
private: 私有类型
        该类型的属性或方法只能在该类中使用，
        在该类的实例、子类中、子类的实例中都不能调用私有类型的属性和

Closure::bind — 复制一个闭包，绑定指定的$this对象和类作用域。
closure
需要绑定的匿名函数。
newthis
需要绑定到匿名函数的对象，或者 null 创建未绑定的闭包。
newscope
想要绑定给闭包的类作用域，或者 'static' 表示不改变。

返回值：
返回一个新的Closure对象或者在失败时返回false。

有时第二个参数为null，有时第三个参数可以不要，这些都跟匿名函数里代码中访问的方式紧密相关。

总结：
1、一般匿名函数中有$this->name类似这样用
$this访问属性方式时，你在使用bind绑定时，第二个参数肯定要写，写出你绑定那个对象实例，
第三个参数要不要呢，要看你访问的这个属性，在绑定对象中的权限属性，
如果是private，protected 你要使用第三个参数 使其变为公有属性,
如果本来就是公有，你可以省略，也可以不省略
2、一般匿名函数中是 类名::静态属性 类似这样的访问方式(比如例子中A::$weight)，你在使用bind绑定时，
第二个参数可以写null,也可以写出具体的对象实例，一般写null就行(写了具体对象实例多此一举)，
第三个参数写不写还是得看你访问的这个静态属性的权限是private还是public,
如果是私有private或受保护protected的，你就得第三个参数必须写，才能使其权限变为公有属性正常访问，
如果本来就是公有public可以不用写，可以省略。



---------------------------php闭包和匿名函数------------------------------------------
匿名函数：
匿名函数其实就是没有名称的函数，匿名函数可以赋值给变量，还能像其他任何PHP函数对象那样传递。
不过匿名函数仍然是函数，因此可以调用，还可以传入参数，适合作为函数或方法的回调。

闭包是指在创建时封装周围状态的函数，即使闭包所在的环境的不存在了，闭包中封装的状态依然存在。

创建匿名函数：
将匿名函数赋给一个变量，通过变量名+()的形式来调用
$greet = function () {
    return "Hello World";
};
echo $greet();
匿名函数和普通的PHP函数很像：常用的句法相同，也接受参数，而且能返回值。不过闭包没有函数名。
注：我们之所以能调用$greet变量，是因为这个变量的值是一个闭包，而且闭包对象实现了__invoke()魔术方法，只要变量名后有()，PHP就会查找并调用__invoke方法。
通常把匿名函数当做函数或方法的回调使用，事实上，很多PHP函数都会用到匿名函数，比如array_map和preg_replace_callback，这是使用PHP匿名函数的绝佳时机。记住，闭包和其他值一样，可以作为参数传入其他PHP函数：
$numberPlusOne = array_map(function ($number) {
    return $number += 1;
}, [1, 2, 3]);

print_r($numberPlusOne);
在匿名函数出现之前，要实现这样的功能，PHP开发者只能单独创建具名函数，然后使用名称引用这个函数：
function incrementNumber ($number) {
    return $number += 1;
}
$numberPlusOne = array_map(‘incrementNumber’,  [1, 2, 3]);
print_r($numberPlusOne);
这样做把回调的实现和使用场所隔离开了，而且使用闭包实现代码更加简洁。

创建闭包：
包含自由变量的函数与为所有这些自由变量提供了变量绑定的环境一起，被称为闭包。
将匿名函数在普通函数中当做参数传入，也可以被返回。这就实现了一个简单的闭包。
function makeHelloWorld($name) {
    $i = 0;
    return function()use($name, &$i){
        echo $name.$i. ' <br>';
        $i++;
    };

}
$hello1 = makeHelloWorld("itbsl");
$hello2 = makeHelloWorld("kevin");
$hello1();   //itbsl0
$hello1();   //itbsl1
$hello1();   //itbsl2
$hello2();   //kevin0
从父作用域继承变量（使用use关键字）
在PHP中必须手动调用闭包对象的bindTo方法或使用use关键字把父作用域的变量及状态附加到PHP闭包中。
而实际应用中，又以使用use关键字实现居多。
use关键字
Laravel框架中也大量使用了闭包，最常见的比如路由定义：
Route::group(['domain' => '{account}.myapp.com'], function () {
    Route::get('user/{id}', function ($account, $id) {
        //
    });
});
这里面的两个function都是匿名函数。而从父作用域继承变量的使用场景在Laravel底层源码中也是俯拾即是，比如：
Model.php（vendor/laravel/framework/src/Illuminate/Database/Eloquent/Model.php）的saveOrFail方法：
public function saveOrFail(array $options = [])
{
    return $this->getConnection()->transaction(function () use ($options) {
        return $this->save($options);
    });
}
该方法的作用是使用事务将模型数据保存到数据库，这里面我们使用匿名函数返回保存状态，同时使用use关键字将父作用域的$options传递给该闭包以便其能够访问这个数据。
此外，还支持传递多个父作用域变量到匿名函数，多个变量以逗号分隔即可。

bindTo方法
闭包是一个对象，所以我们可以在闭包中使用$this关键字获取闭包的内部状态，闭包对象的默认状态没什么用，需要注意的是其中的__invoke魔术方法和bindTo方法。
__invoke的作用前面已经说过，当尝试以调用函数的方式调用一个对象时，__invoke() 方法会被自动调用。
通过bindTo方法，我们可以把闭包的内部状态绑定到其他对象上。这里bindTo方法的第二个参数显得尤为重要，其作用是指定绑定闭包的那个对象所属的PHP类，这样，闭包就可以在其他地方访问邦定闭包的对象中受保护和私有的成员变量。


--------------------PHP闭包的bind和bindTo------------------------------
Closure类摘要如下：
Closure {
    __construct ( void )
    public static Closure bind (Closure $closure , object $newthis [, mixed $newscope = 'static']
    public Closure bindTo (object $newthis [, mixed $newscope = 'static' ])
}
方法说明：
Closure::__construct — 用于禁止实例化的构造函数
Closure::bind — 复制一个闭包，绑定指定的$this对象和类作用域。
Closure::bindTo — 复制当前闭包对象，绑定指定的$this对象和类作用域。

闭包bind方法：
<?php
/**
 * 复制一个闭包，绑定指定的$this对象和类作用域。
 */
class Animal {
    private static $cat = "cat";
    private $dog = "dog";
    public $pig = "pig";
}
/*
 * 获取Animal类静态私有成员属性
 */
$cat = static function() {
    return Animal::$cat;
};

/*
 * 获取Animal实例私有成员属性
 */
$dog = function() {
    return $this->dog;
};

/*
 * 获取Animal实例公有成员属性
 */
$pig = function() {
    return $this->pig;
};
//给闭包绑定了Animal实例的作用域，但未给闭包绑定$this对象
$bindCat = Closure::bind($cat, null, new Animal());

//给闭包绑定了Animal类的作用域，同时将Animal实例对象作为$this对象绑定给闭包
$bindDog = Closure::bind($dog, new Animal(), 'Animal');

//将Animal实例对象作为$this对象绑定给闭包,保留闭包原有作用域
$bindPig = Closure::bind($pig, new Animal());

echo $bindCat(),'<br>';// 根据绑定规则，允许闭包通过作用域限定操作符获取Animal类静态私有成员属性
echo $bindDog(),'<br>';// 根据绑定规则，允许闭包通过绑定的$this对象(Animal实例对象)获取Animal实例私有成员属性
echo $bindPig(),'<br>';// 根据绑定规则，允许闭包通过绑定的$this对象获取Animal实例公有成员属性

bind函数：
参数1($closure) : 表示闭包函数
参数2($newthis): 相当于在函数内/外调用的区别，传类的实例表示在内部调用，NULL相当于在外部调用
参数3($newscope): 相当于类和实例调用的区别，函数的作用域， 传类表示静态调用方式，内部可以“类名::属性”的方式使用；实例表示实例调用方式，内部可以“->”



